						
						конспект - 1

1) Base javascript 
2) opreations --> операции
3) tyization, duck typing --> типизация. утиная типизация
4) value types and reference types типы javaskript
5) objects --> обьекты
6) arrays --> массивы
7) function declaration and fuction expression 
9) lexical scoping -->


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


						!интересное примечание на счет VAR and LET!



   как работает VAR:				что же будет в случае LET:

  |for (var i = 0; i < 10; i++) {		|for (let i = 0; i < 10; i++) {		! почему так? -->  LET работает у нас в блочной области видимости, и как только мы вышли из неё, LET не слато ФИЗИЧЕСКИ!
  |}						|}					Если мы хотим узнать значение i --> console.log(i) следует написать в теле блочной области !
  |console.log(i); // выдаст 10			|console.log(i); // выдаст ошибку
						|Uncaught ReferenceError: i is not defined at <anonymous>:4:13




					что же будет если прописать VAR i; and LET i:


  |var i = "foo";
  |for (let i = 0; i < 10; i++) {
  |  console.log(i); // сначал выведится все значения (let i) которое было объявлено внутри условия
  |}
  |console.log(i); // а потом (var i)
вывод:
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  "foo"

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	основные особенности


- выполняется на виртуальной машине
- утиная типизация
- автомотическое приведение типов (например строка "пятьдесят" и строка "два" получится строка "пятдесят два")
- мультипорадигменность

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	сравнение переменных


				  === --> строгое равенство(strict equal)

  '10' > 3 // true		3 === 3 // true		
  '10' > '3' // false		3 === '3' // false (потому что при === js берет оба значения и смотрит их типы ПРЯМО, ПО ФАКТУ)

				  == --> равенство(abstact equal)
  				3 == '3' // true (потому что при == js приводит оба значения к одному типу и сравнивает)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	елементарные типы(примитивы) 


- number - 1, 2, 0.3 (числа представлены в формате float64)
- string - 'a', 'asdsd'
- coolean - true, false
- null
- undefined

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


						2) opreations --> операции


  |let a = parseint('123', 10);
  |let v = '123' * 1;
  |a === v;


 1 + 1 //2 --------------------->!Операция '+' определена для строк и для чисел, 
 1 + '1' // '11'			 операции '-', '*', '/' - определена только для чисел, но 
'1' - 1 // 0			 операции над строками более приорететные чем над числами!
'1' +- 1 // '1-1'
 1 + [(пустой массив)] // '1'
 1 + (1,2,3) //4
 1 ----- 1 // 0 (- на - дает +. если написать четное кол-во минусов будет // 2)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	
						3) tyization

  typef - проверяет тип данных (возвращает строку с описанем типа)

- typef "asdasd" === 'стринг'
- typef new String("asdasd") === 'object'
- typef 0 === 'nomber'
- typef "true" === 'boolean'
- typef "undefined" === 'undefined'
- typef "null" === 'object'

 
  динамическая типизация - это когда "на лету" происходит определение типа (пример: a = "hello" --> typ:string; f = 4 --> type:nomber)

  |function divideBy5(a) {
  |  return a/5;
  |}
  |divideBy5(30) // 5
  |divideBy5('30') // будет тоже 5 --> (как сказано выше - операторы '-', '*', '/' - определены только для чисел.)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


						5) objects


- обьект: new object() or {}
- обертки для примеров: boolean, number, string
- массив: new array() or {}
- функция: function() or {}
- регулярное выражение: new RegExp

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


-) объекты изменяемы(mutable) по своей природе:

  |let obj = {};
  |obj.asd = 'asd';
  |console.log(obj.asd); // 'asd'

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


-) объекты сравниваются по ссылке:

  |{} === {} // false
  |let obj = {};
  |obj === obj; // true

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


-) переменные хранят ссылки на свои объекты:

  |let a = {};
  |let v = a;	!тут мы 'v' присваеваем не значение 'a', а присваевает ссылку, со
  |a.asd = 1;	значением как у 'v' Если попробовать их сравнить будет --> true!
  |v.asd // 1

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


-) динамическое изменение полей:

  добавление полей:
   |let a = {};
   |a.foo = 'bar';

  удаление полей:
   |delete a.foo; // true ------>!delete --> может удалать только поля объектов, он не может
   |delete a; //false		 удалять сам объект!

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


 -) основные отличия объектов от элементарных типов


элементарные типы:


1) приметивы неизменны:			  2) примитивы сравниваются по значению:	 3) при необходимости приводятся к обьекту:
					 						
  let str = 'asdasd';			     'asdasd' === 'asdasd' // true		    'asd'.length // 3
  str.foo = 123;			 						
  console.log(str.foo); //undefined	 						



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


						6) arrays --> массивы


  Массив - это тот же самый объект, который имеет больше фичей...

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


- специально-организованный объект

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


- можем создавать как с помощью [] так и new Array()

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


- new Array() принимает значение - елементы массива, либо количество своих елементов, если передавать в new Array() одно значение
  new Array(1, 2, 3) // [1, 2, 3]
  new Array(4) // создаст 4 зарезервированных места [undefined, undefined, undefined, undefined] --> где 'undefined' это зарезервированное место

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


- мы можем хранить в 1 массиве что угодно:
  let a = [ 123, 'fes', '123', [[[массив в котором массив, в котором массив]]], {fsd: 'fer' - объекты которые хранят другие объекты}, true];

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


- имеет методы методы для работы с елементами массива
  push
  pop
  shift
  unshift
  slice
  join 

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


- имеет специальное свойство - length, но есть ньюансы:

  [1, 2, 3].length // 3

  let a = [];

  a[5] = 1;

  a.length // 6 --> это выглядит примерно так: [empty x5, 1(та самая еденичка которую мы поставили в массив с индексом 5)]

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


						7) function --> функции


	- объект который можно вызвать (имеет скрытый метод который вызывается с помощью оператора скобки или оператора new (если функция конструктор)) 


  |  function foo() {	      |  function bar() {
  |return 1		      |}
  |}			      |bar(); // вернет undefined
  |foo(); // вернет 1

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

	- можно добавлять любые свойства (оналогично object)

  |  function foo() {
  |}
  |foo.re = "1";
  |foo.re // вернет "1"
но если вызвать просто foo:
  |foo(); // вернет undefined
 
-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

	- отсутствует проверка на число аргументов

  |function square(arg(1)) {	!если применять length к функции --> будет показано число аргументов, которые описаны
  |  return arg * arg;		 в аргументах функции!
  |}
  |square.length // вернет 1


  |function square(arg(1), dfd(2), aefe(3)) {	
  |  return arg * arg;		 
  |}
  |square.length // вернет 3

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


	- создает области видимости (scope)

  1|function a() {			так этот код видит js -->	1|function a() {
  2|  console.log(a); // undefuned					2|  let a; <-- функция находит значение "а" в 4той строке, и вставляет его вверх БЕЗ ПРИСВАИВАНИЯ
  3|  let a = 10;							3|  console.log(a) // undefuned 
  4|  console.log(a); // 10						4|  let a = 10;
  5|}									5|  console.log(a); // 10
  6|a(); // 10  							6|}  
									7|a(); //10

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

	- способы возврата результата

	1)				2)				3)
  |function a() {		|function a() {			|function a () {
  |  var a = 10;		|  var a = 10;			|  var a = 10;
  |  return a;			|}				|}
  |}				|a(); // undefined		|new a; // a{}
  |a(); //10

1) Описали футкцию, и вернули значение через return.
2) Если не возвращать функции ничего, будет undefined.
3) Способ через оператор new. ниже еще пример:

  |function A() {
  |  this.foo = 'bar';
  |}
  |new A()
Вывод:
  |A {foo: 'bar'}

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


	- аргументы функции:

 -специальный объект который содержит список переданных аргументов
 -не является массивом
 -содержит length которое указывает на количество реальных переданных аргументов
 -содержит свойство callee, которое являеться указателем на текущую функцию


								!!
  						   |function f1() {
   						   |	console.log(arguments); // [1,2,3]
    						   |	console.log(arguments.lwngth); // 3
    						   |	console.log(arguments.callee); // выведет код данной функции
    						   |}
   						   |f1(1,2,3); 
								!!

 
 -) |function foo() {
    |    console.log(arguments); // VM995:2 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    |    arguments[10] = 23;
    |    console.log(arguments); // VM995:4 Arguments(3) [1, 2, 3, 10: 23, callee: ƒ, Symbol(Symbol.iterator): ƒ] --> '1,2,3' идут как индекс, а '10: 23' как объект. код снизу это демонстрирует...
    |}
    |foo(1,2,3)


    |function foo() {
    |    console.log(arguments);
    |    console.log(arguments.length); // VM1371:2 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]  VM1371:3 3 --> длинна аргументов 3
    |    arguments[10] = 23;
    |    console.log(arguments);
    |    console.log(arguments.length); // VM1371:5 Arguments(3) [1, 2, 3, 10: 23, callee: ƒ, Symbol(Symbol.iterator): ƒ]  VM1371:6 3 --> длинна аргументов тоже 3
    |}
    |foo(1,2,3)

-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -


	- области видимости

 -определяется во время создания функции
 -не меняется при передаче функции
 -образует цепочку областей видимости
 -образует 'замыкание'


 -) | function f1() {
    |     let a = 10;
    |     let d = 1;
    |     function f2() {
    |         let a = 4;
    |         console.log('a=', a); // a= 4
    |         console.log('d=', d); // d= 1
    |         d = 2;
    |         a = 11;
    |         console.log('a=', a);  // a= 11
    |         console.log('d=', d); // d= 2
    |     }
    |     f2()
    |     console.log('a=', a); // a= 10
    |     console.log('d=', d); // d= 2
    | }
    | f1()
